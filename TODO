% Bisection Method
syms x;
y = input('Enter non-linear equations: ');
a = input('Enter first value: ');
b = input('Enter second value: ');
e = input('error: ');
fa = eval(subs(y,x,a));
fb = eval(subs(y,x,b));

if fa*fb > 0 
    disp('Given initial values do not bracket the root.');
else
    c = (a+b)/2;
    fc = eval(subs(y,x,c));
    fprintf('\n\na\t\t\tb\t\t\tc\t\t\tf(c)\n');
    while abs(fc)>e
        fprintf('%f\t%f\t%f\t%f\n',a,b,c,fc);
        if fa*fc< 0
            b =c;
        else
            a =c;
        end
        c = (a+b)/2;
        fc = eval(subs(y,x,c));
    end
    fprintf('\nRoot is: %f\n', c);
end

%Newtopn-Raphson Method
% Setting x as symbolic variable
syms x;

% Input Section
y = input('Enter non-linear equations: ');
a = input('Enter initial guess: ');
e = input('Tolerable error: ');
N = input('Enter maximum number of steps: ');
% Initializing step counter
step = 1;

% Finding derivate of given function
g = diff(y,x);

% Finding Functional Value
fa = eval(subs(y,x,a));

while abs(fa)> e
    fa = eval(subs(y,x,a));
    ga = eval(subs(g,x,a));
    if ga == 0
        disp('Division by zero.');
        break;
    end
    
    b = a - fa/ga;
    fprintf('step=%d\ta=%f\tf(a)=%f\n',step,a,fa);
    a = b;
    
    if step>N
       disp('Not convergent'); 
       break;
    end
    step = step + 1;
end

fprintf('Root is %f\n', a);

%Regular Falsi method
syms x;
% Input Section
y = input('Enter non-linear equations: ');
a = input('Enter initial guess: ');
e = input('Tolerable error: ');
N = input('Enter maximum number of steps: ');
% Initializing step counter
step = 1;

% Finding derivate of given function
g = diff(y,x);

% Finding Functional Value
fa = eval(subs(y,x,a));

while abs(fa)> e
    fa = eval(subs(y,x,a));
    ga = eval(subs(g,x,a));
    if ga == 0
        disp('Division by zero.');
        break;
    end
    
    b = a - fa/ga;
    fprintf('step=%d\ta=%f\tf(a)=%f\n',step,a,fa);
    a = b;
    
    if step>N
       disp('Not convergent'); 
       break;
    end
    step = step + 1;
end

fprintf('Root is %f\n', a);




% To solve the system of linear equations using Gauss-Elimination method
n = input('Enter the order of matrix: ');
A = zeros(n, n+1);
fprintf('\nEnter the elements of augmented matrix row-wise:\n\n');
for i=1:n
    for j=1:n+1
        fprintf('A[%d][%d] : ', i,j);
        A(i,j) = input('');
    end
end

for j=1:n % loop for the generation of upper triangular matrix
    for i=1:n
        if i>j
            c=A(i,j)/A(j,j);
            for k=1:n+1
                A(i,k)=A(i,k)-c*A(j,k);
            end
        end
    end
end

x = zeros(n,1);
x(n)=A(n,n+1)/A(n,n);
% this loop is for backward substitution
for i=n-1:-1:1
    sum=0;
    for j=i+1:n
        sum=sum+A(i,j)*x(j);
    end
    x(i)=(A(i,n+1)-sum)/A(i,i);
end

fprintf('\nThe solution is: \n');
for i=1:n
    fprintf('\nx%d = %f\t',i,x(i)); % x1, x2, x3 are the required solutions
end



% Gauss-Seidel Method in MATLAB
function x = gauss_siedel( A ,B )
disp ( 'Enter the system of linear equations in the form of AX=B')

%Inputting matrix A
A = input ( 'Enter matrix A :   \n')
% check if the entered matrix is a square matrix
[na , ma ] = size (A);
if na ~= ma
    disp('ERROR: Matrix A must be a square matrix')
    return
end

% Inputting matrix B
B = input ( 'Enter matrix B :   ')
% check if B is a column matrix
[nb , mb ] = size (B);
if nb ~= na || mb~=1
   disp( 'ERROR: Matrix B must be a column matrix')
   return
end

% Separation of matrix A into lower triangular and upper triangular matrices
% A = D + L + U
D = diag(diag(A));
L = tril(A)- D;
U = triu(A)- D

% check for convergence condition for Gauss-Seidel method
e= max(eig(-inv(D+L)*(U)));
if abs(e) >= 1
    disp ('Since the modulus of the largest Eigen value of iterative matrix is not less than 1') 
    disp ('this process is not convergent.')
    return
end

% initial guess for X..?
% default guess is [ 1 1 .... 1]
r = input ( 'Any initial guess for X? (y/n):   ','s');
switch r 
    case 'y'
        % asking for initial guess
    X0 = input('Enter initial guess for X :\n')
        % check for initial guess
    [nx, mx] = size(X0);
        if nx ~= na || mx ~= 1
        disp( 'ERROR: Check input')
        return
    end
    otherwise
    X0 = ones(na,1);
end

% allowable error in final answer
t = input ( 'Enter the error allowed in final answer:  ');
tol = t*ones(na,1);
k= 1;

X( : , 1 ) = X0;
err= 1000000000*rand(na,1);% initial error assumption for looping
while sum(abs(err) >= tol) ~= zeros(na,1)
    X ( : ,k+ 1 ) = -inv(D+L)*(U)*X( : ,k) + inv(D+L)*B;% Gauss-Seidel formula
    err = X( :,k+1) - X( :, k);% finding error
    k = k + 1;
    
end

fprintf ('The final answer obtained after %g iterations is  \n', k)
X( : ,k)


%Simpson

syms x

% Lower Limit
a = 4;

% Upper Limit
b = 5.2;

% Number of Segments
n = 6;

% Declare the function
f1 = log(x);

% inline creates a function of string containing in f1
f = inline(f1);

% h is the segment size
h = (b - a)/n;

% X stores the summation of first and last segment
X = f(a)+f(b);

% variables Odd and Even to store
% summation of odd and even
% terms respectively
Odd = 0;
Even = 0;
for i = 1:2:n-1
	xi=a+(i*h);
	Odd=Odd+f(xi);
end
for i = 2:2:n-2
	xi=a+(i*h);
	Even=Even+f(xi);
end

% Formula to calculate numerical integration
% using Simpsons 1/3 Rule
I = (h/3)*(X+4*Odd+2*Even);

disp('The approximation of above integral is: ');
disp(I);


%Jacobi
A = input('Enter a coeefificient matrix A: ');

B = input('Enter Source Vector B: ');
P = input('Enter intital Guess vector: ');
n = input('Enter no of iterations: ');
N = length(B);
X = zeros(N,1);

for j=1:n
    for i = 1:N
        X(i) = (B(i)/A(i,i)) - (A(i,[1:i-1,i+1:N]*P([1:i-1,i+1:N]))/A(i,i));
    end
    p=X;
end
disp(p)


%Trapozoidal
% MATLAB code for calculate Y is a vector
% of numeric data containing function values 
% for f(x) = 2^x in domain [1,5]
Y = [2 4 8 16 32];
  
% Integrate the data using 'trapz(Y)'
% with unit spacing (by default)
Q = trapz(Y);
  
% display the result
disp('The approximate Integration using trapz(Y) = ');
disp(Q);


f=@(x)(sin(x));
a=input('Enter lower limit');
b=input('upper limit');
n= input('No. of sub intervals');

h=(b-a)/n;
s0=f(a)+f(b);
s1=0;
for i=1:n-1
    x=+i*h;
    s1=s1+f(x);
end
s=(h/2)*(s0+2*s1);
fprintf(s);


















