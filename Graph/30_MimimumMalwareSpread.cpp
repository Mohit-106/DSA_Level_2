//DSU

// class Solution {
// public:
    
//     int find(int x , vector<int>&par){
//         if(par[x]==x){
//             return x;
//         }
//         par[x]=find(par[x],par);
//         return par[x];
//     }
    
//     void merge(int x , int y, vector<int>&par, vector<int>&size){
        
//         if(size[x]>size[y]){
//             par[y]=x;
//             size[x]+=size[y];
//         }else if(size[x]<size[y]){
//             par[x]=y;
//             size[y]+=size[x];
//         }else{
//             par[x]=y;
//             size[y]+=size[x];  
//         }
        
//     }
    
//     int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
//         vector<int>par(graph.size());
//         vector<int>size(graph.size());
//         for(int i=0;i<par.size();i++){
//             par[i]=i;
//             size[i]=1;
//         }
//         for(int i=0;i<graph.size();i++){
//             for(int j=0;j<graph[0].size();j++){
//                 if(i!=j && graph[i][j]==1){
//                     int v1 = find(i,par);
//                     int v2 = find(j,par);
//                     if(v1!=v2){
//                         merge(v1,v2,par,size);
//                     }
//                 }
//             }
//         }  
//         vector<int>inf(graph.size());
//         for(int i : initial){
//             int parent = find(i,par);
//             inf[parent]++;
//         }
//         sort(initial.begin(),initial.end());
//         int ans = initial[0];
//         int ans_size = 0;
//         for(int i : initial){
//             int parent = find(i,par);
//             if(inf[parent]==1){
//                 if(size[parent]>ans_size){
//                     ans = i;
//                     ans_size = size[parent];
//                 }
//             }
            
//         }
//         return ans;
        
//     }
// };



//DFS


// class Solution {
//     public int minMalwareSpread(int[][] graph, int[] infected) {
//         HashSet<Integer> setInfected = new HashSet<>();
//         Arrays.sort(infected);
//         int count = 0;
//         for(int val: infected){
//             setInfected.add(val);
//         }
//         int ans = infected[0]; 
//         for(int curr=0 ;curr<infected.length; curr++){
//             boolean[] visited = new boolean[graph.length];
//             int temp = dfs(graph, visited, infected[curr], infected[curr], setInfected);
//             if(temp>count){
//                 count = temp;
//                 ans = infected[curr];
//             }
//         }
//         return ans;
//     }
//     // dfs returns min_value if more than 2 infected in connected sets
//     static int dfs(int[][] graph, boolean[] visited, int initialInfected, int curr, HashSet<Integer> setInfected){
//         if(visited[curr]){
//             return 0;
//         }
//         if(curr!=initialInfected && setInfected.contains(curr)){
//             return Integer.MIN_VALUE;
//         }
//         visited[curr] = true;
//         int count=0;
//         for(int nbr=0; nbr<graph[curr].length; nbr++){
//             if(graph[curr][nbr]==1 && visited[nbr]==false){
//                 int val = dfs(graph, visited, initialInfected, nbr, setInfected);
//                 if(val==Integer.MIN_VALUE){ return val;}
//                 count+= val;
//             }   
//         }
//         return count+1;
//     }
// }